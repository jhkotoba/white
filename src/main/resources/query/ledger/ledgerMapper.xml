<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd"> 

<mapper namespace="ledgerMapper">
	<!-- 해당 유저  MoneyRecord Count-->
	<select id="userMoneyRecordCount" resultType="int" parameterType="String">
	/* userMoneyRecordCount */
	SELECT COUNT(1) FROM money_record
	WHERE user_seq = #{userSeq}
	</select>					

	<select id="getMoneyRecord" resultType="java.util.Map" parameterType="java.util.Map">
		/* getMoneyRecord */		
		SELECT
			rec.record_seq			AS recordSeq,
			rec.group_seq			AS groupSeq,
			rec.user_seq			AS userSeq,
			DATE_FORMAT(rec.record_date,'%Y-%m-%d %H:%i:%s') AS recordDate,
			rec.content 			AS content,
			rec.purpose_seq 		AS purposeSeq,
		   	pur.purpose 			AS purpose,
		   	rec.pur_detail_seq 		AS purDetailSeq,
      		IFNULL(purDtk.pur_detail,'') AS purDetail,				
			rec.user_bank_seq 		AS userBankSeq,	
			rec.move_to_seq			AS moveToSeq,	
      		IFNULL(bank.bank_name, '현금')	AS bankName,
      		IFNULL(bank.bank_account, 'readyMoney')	AS bankAccount,
			IFNULL(bank.bank_now_use_yn,'X') AS bankNowUseYN, 
			rec.in_exp_money 		AS inExpMoney,
			rec.ready_money			AS readyMoney,
			rec.result_bank_money	AS resultBankMoney
		FROM money_record rec
		LEFT OUTER JOIN purpose pur
			ON rec.purpose_seq = pur.purpose_seq
		LEFT OUTER JOIN purpose_detail purDtk
			ON rec.pur_detail_seq = purDtk.pur_detail_seq
		LEFT OUTER JOIN user_bank bank
    		ON rec.user_bank_seq = bank.user_bank_seq 
		WHERE 1=1
		AND rec.user_seq = #{userSeq} 
		AND rec.record_date >= #{startDate}
		AND rec.record_date &lt; #{endDate}
		<if test="purSeqSearch != ''">
			AND rec.purpose_seq = #{purSeqSearch}
		</if>		
		ORDER BY rec.record_date desc, rec.record_seq desc
	</select>
	<!-- <select id="getMoneyRecord" resultMap="MoneyRecordVO" parameterType="MAP">		
		SELECT
			RECORD_SEQ,
			USER_SEQ,
			DATE_FORMAT(RECORD_DATE,'%Y-%m-%d %H:%i:%s') AS RECORD_DATE,
			CONTENT,
			PURPOSE_SEQ,
		    (SELECT PURPOSE FROM PURPOSE P
				WHERE M.PURPOSE_SEQ = P.PURPOSE_SEQ) AS PURPOSE,  
			BANK_NAME,
			BANK_ACCOUNT,			
			BANK_RECORD_USE_YN,
			IN_EXP_MONEY,
			READY_MONEY,
			RESULT_BANK_MONEY
		FROM MONEY_RECORD M
		WHERE 1=1
		AND USER_SEQ = #{userSeq} 
		AND RECORD_DATE >= #{startDate}
		AND RECORD_DATE &lt; #{endDate} 
		ORDER BY RECORD_DATE DESC, RECORD_SEQ DESC
	</select> -->
	
	<select id="getLatestMoneyRecord" resultType="java.util.Map" parameterType="java.util.Map">
		/* getLatestMoneyRecord */	
		SELECT
			rec.record_seq			AS recordSeq,
			rec.user_seq			AS userSeq,
			rec.group_seq			AS groupSeq,
			DATE_FORMAT(rec.record_date,'%Y-%m-%d %H:%i:%s') AS recordDate,
			rec.content 			AS content,
			rec.purpose_seq 		AS purposeSeq,
		   	pur.purpose 			AS purpose,	
		   	rec.pur_detail_seq 		AS purDetailSeq,
      		IFNULL(purDtl.pur_detail,'') AS purDetail,						
			rec.user_bank_seq 		AS userBankSeq,			
			rec.move_to_seq			AS moveToSeq,	
      		IFNULL(bank.bank_name, '현금')	AS bankName,
      		IFNULL(bank.bank_account, 'readyMoney')	AS bankAccount,
			IFNULL(bank.bank_now_use_yn,'X') AS bankNowUseYN, 
			rec.in_exp_money 		AS inExpMoney,
			rec.ready_money			AS readyMoney,
			rec.result_bank_money	AS resultBankMoney
		FROM money_record rec
		LEFT OUTER JOIN purpose pur
			ON rec.purpose_seq = pur.purpose_seq
		LEFT OUTER JOIN purpose_detail purDtl
			ON rec.pur_detail_seq = purDtk.pur_detail_seq
		LEFT OUTER JOIN user_bank bank
    		ON rec.user_bank_seq = bank.user_bank_seq 
		WHERE 1=1
		AND rec.user_seq = #{userSeq}		
		ORDER BY rec.record_date desc, rec.record_seq desc
		Limit 100	
		<!-- SELECT
			RECORD_SEQ,
			USER_SEQ,
			DATE_FORMAT(RECORD_DATE,'%Y-%m-%d %H:%i:%s') AS RECORD_DATE,
			CONTENT,
			PURPOSE_SEQ,
		    (SELECT PURPOSE FROM PURPOSE P
				WHERE M.PURPOSE_SEQ = P.PURPOSE_SEQ) AS PURPOSE,  
			BANK_NAME,
			BANK_ACCOUNT,			
			BANK_RECORD_USE_YN,
			IN_EXP_MONEY,
			READY_MONEY,
			RESULT_BANK_MONEY
		FROM money_record M
		WHERE 1=1
		AND USER_SEQ = #{userSeq}		
		ORDER BY RECORD_DATE DESC, RECORD_SEQ DESC
		Limit 100 -->
	</select>
	
	<select id="serachLastRow" resultType="java.util.Map" parameterType="java.util.Map">
		/* serachLastRow */	
		
		SELECT
			rec.record_seq			AS recordSeq,
			rec.group_seq			AS groupSeq,
			rec.user_seq			AS userSeq,
			DATE_FORMAT(rec.record_date,'%Y-%m-%d %H:%i:%s') AS recordDate,
			rec.content 			AS content,
			rec.purpose_seq 		AS purposeSeq,
		   	pur.purpose 			AS purpose,	
		   	rec.pur_detail_seq 		AS purDetailSeq,
      		IFNULL(purDtk.pur_detail,'') AS purDetail,				
			rec.user_bank_seq 		AS userBankSeq,			
			rec.move_to_seq			AS moveToSeq,
      		IFNULL(bank.bank_name, '현금')	AS bankName,
      		IFNULL(bank.bank_account, 'readyMoney')	AS bankAccount,
			IFNULL(bank.bank_now_use_yn,'X') AS bankNowUseYN, 
			rec.in_exp_money 		AS inExpMoney,
			rec.ready_money			AS readyMoney,
			rec.result_bank_money	AS resultBankMoney
		FROM money_record rec
		LEFT OUTER JOIN purpose pur
			ON rec.purpose_seq = pur.purpose_seq
		LEFT OUTER JOIN purpose_detail purDtk
			ON rec.pur_detail_seq = purDtk.pur_detail_seq
		LEFT OUTER JOIN user_bank bank
    		ON rec.user_bank_seq = bank.user_bank_seq    		
		WHERE 1=1
		AND rec.user_seq = #{userSeq}
		AND rec.user_bank_seq = #{userBankSeq}
		AND rec.record_date &lt; #{recordDate} 	
		ORDER BY rec.record_date desc, rec.record_seq desc
		Limit 1	
		
		<!-- SELECT
			rec.record_seq			AS recordSeq,
			rec.group_seq			AS groupSeq,
			rec.user_seq			AS userSeq,
			DATE_FORMAT(rec.record_date,'%Y-%m-%d %H:%i:%s') AS recordDate,
			rec.content 			AS content,
			rec.purpose_seq 		AS purposeSeq,
		   	pur.purpose 			AS purpose,					
			rec.user_bank_seq 		AS userBankSeq,			
			rec.move_to_seq			AS moveToSeq,
      		IFNULL(bank.bank_name, '현금')	AS bankName,
      		IFNULL(bank.bank_account, 'readyMoney')	AS bankAccount,
			IFNULL(bank.bank_now_use_yn,'X') AS bankNowUseYN, 
			rec.in_exp_money 		AS inExpMoney,
			rec.ready_money			AS readyMoney,
			rec.result_bank_money	AS resultBankMoney
		FROM money_record rec
		LEFT OUTER JOIN purpose pur
			ON rec.purpose_seq = pur.purpose_seq
		LEFT OUTER JOIN user_bank bank
    		ON rec.user_bank_seq = bank.user_bank_seq
    		AND bank.bank_account = #{bankAccoun}
		WHERE 1=1
		AND rec.user_seq = #{userSeq}
		AND rec.record_date &lt; #{recordDate} 	
		ORDER BY rec.record_date desc, rec.record_seq desc
		Limit 1	 -->
		
			
		<!-- SELECT
			RECORD_SEQ,
			USER_SEQ,
			DATE_FORMAT(RECORD_DATE,'%Y-%m-%d %H:%i:%s') AS RECORD_DATE,
			CONTENT,
			(SELECT PURPOSE FROM PURPOSE P
				WHERE M.PURPOSE_SEQ = P.PURPOSE_SEQ) AS PURPOSE,   
			BANK_NAME,
			BANK_ACCOUNT,			
			BANK_RECORD_USE_YN,
			IN_EXP_MONEY,
			READY_MONEY,
			RESULT_BANK_MONEY
		FROM MONEY_RECORD M
		WHERE 1=1
		AND USER_SEQ = #{userSeq}		
		AND BANK_ACCOUNT = #{bankAccount}
		AND RECORD_DATE &lt; #{recordDate} 
		ORDER BY RECORD_DATE DESC, RECORD_SEQ DESC
		Limit 1 -->
	</select>
	
	<!-- 해당유저 money_record 테이블 내역 전부 조회 (백업용) -->
	<select id="selectAllMoneyRecord" resultType="MoneyRecordBean" parameterType="String">
	/* selectAllMoneyRecord */
		SELECT						
			rec.group_seq AS groupSeq,	
			record_date AS recordDate								
			,content AS content						
			,purpose_seq AS purposeSeq
			,user_bank_seq	AS userBankSeq			
			,move_to_seq AS moveToSeq
			,in_exp_money AS inExpMoney		
			,ready_money AS readyMoney			
			,result_bank_money AS resultBankMoney								
			,reg_date AS regDate							
		FROM money_record
		WHERE user_seq = #{userSeq}
	</select>
	
	<select id="selectRecordTotalCount" resultType="int" parameterType="String">
		SELECT COUNT(1) FROM money_record
		WHERE user_seq = #{userSeq}
	</select>
	
		
	<select id="getPurposeList" resultType="PurposeBean" parameterType="String">	
		SELECT 
			purpose_seq AS purposeSeq,
	  		<!-- user_seq AS userSeq, -->
	  		pur_order AS purOrder,
	 		purpose AS purpose
		FROM purpose
		WHERE 1=1
		AND user_seq = #{userSeq}
		ORDER BY pur_order
	</select>	
	
											   
	<select id="getPurposeDtlList" resultType="PurposeDetailBean" parameterType="String">
		SELECT
			pur_detail_seq AS purDetailSeq,
			purpose_seq AS purposeSeq,
			<!-- user_seq AS userSeq, -->
			pur_dtl_order AS purDtlOrder,
			pur_detail AS purDetail			
		FROM purpose_detail
		WHERE 1=1
		AND user_seq = #{userSeq}
		ORDER BY pur_dtl_order		
	</select>	
	
	<!-- 추후 getPurposeList 동적쿼리 이용해서 합칠것-->
	<select id="getPurposeList_backup" resultType="PurposeBean" parameterType="String">	
	SELECT 
		purpose_seq AS purposeSeq,
  		user_seq AS userSeq,
  		pur_order AS purOrder,
 		purpose AS purpose
	FROM purpose
	WHERE 1=1
	AND user_seq = #{userSeq}
	ORDER BY purpose_seq
	</select>	
	
	<select id="getBankList" resultType="UserBankBean" parameterType="String">	
		SELECT
		  user_bank_seq AS userBankSeq,
		  bank_name AS bankName,
		  bank_account AS bankAccount,
		  bank_now_use_yn AS bankNowUseYN
		FROM user_bank
		WHERE user_seq = #{userSeq}
	</select>
	
	<select id="getUseBankList" resultType="Map" parameterType="String">	
		SELECT
		  user_bank_seq AS userBankSeq,
		  bank_name AS bankName,
		  bank_account AS bankAccount,
		  bank_now_use_yn AS bankNowUseYN
		FROM user_bank
		WHERE bank_now_use_yn = 'Y'
		AND user_seq = #{userSeq}
	</select>
	
	<insert id="setInsertRecode" parameterType="Map"
		useGeneratedKeys="true" keyProperty="recordSeq" keyColumn="record_seq">
		
		INSERT INTO money_record(	
			group_seq,		
			user_seq, 
			record_date, 
			content, 
			purpose_seq,
			pur_detail_seq,
			
					
			user_bank_seq,	
			move_to_seq,	
			<!-- bank_name, 
			bank_account, 
			bank_record_use_yn,  -->
			
			in_exp_money, 
			ready_money, 
			result_bank_money,
			reg_date
		)
		VALUES		
		(		
			<choose>
				<when test="groupSeq != null">
					#{groupSeq},
				</when>
				<otherwise>
					0,					
				</otherwise>
			</choose>
			#{userSeq},
			#{recordDate},		
			#{content},
			#{purposeSeq},
			#{purposeDtlSeq}, <!-- 테스트중 --><!-- #{pur_detail_seq}, -->
			
			
						
			<choose>
				<when test="userBankSeq == 0">
					null,
						<choose>
							<when test="purposeSeq == 0 and moveToSeq != 0">
								#{moveToSeq},
							</when>
							<otherwise>
								null,
							</otherwise>
						</choose>
					
					#{inExpMoney},
					IFNULL((SELECT ready_money 
						FROM(
							SELECT ready_money
								FROM money_record
								WHERE user_seq = #{userSeq}
								AND record_date &lt; #{recordDate}
	         					AND user_bank_seq IS NULL
	          					ORDER BY record_date DESC, record_seq DESC
	          					LIMIT 1
	          				) AS ready_money
	          		),0) + #{inExpMoney},
					0,
					now()
				</when>
				<when test="userBankSeq != 0">
					#{userBankSeq},
						<choose>
							<when test="purposeSeq == 0 and moveToSeq != 0">
								#{moveToSeq},
							</when>
							<otherwise>
								null,
							</otherwise>
						</choose>				
					#{inExpMoney},
					0,
					IFNULL((SELECT result_bank_money 
						FROM(
							SELECT result_bank_money
								FROM money_record
								WHERE user_seq = #{userSeq}
								AND record_date &lt; #{recordDate}
	         					AND user_bank_seq = #{userBankSeq}							
	          					ORDER BY record_date DESC, record_seq DESC
	          					LIMIT 1
	          				) AS result_bank_money
	          		),0) + #{inExpMoney},
	          		now()          							
				</when>
			</choose>						
			)		
	</insert>
	
	<!-- 새로 입력하거나 수정, 삭제시  기록시간의 이후시간은  금액 +- 수정  -->
	<update id="updateNextModify" parameterType="Map">
		UPDATE money_record
		<choose>
			<!-- <when test="bankAccount == 'readyMoney'"> -->
			<when test="userBankSeq == 0">
				<if test="updateType == 'insert'">
					SET ready_money = ready_money + #{inExpMoney}
				</if>
				<if test="updateType == 'delete'">
					SET ready_money = (ready_money - #{inExpMoney})
				</if>
			</when>
			<!-- <when test="bankAccount != 'readyMoney'"> -->
			<otherwise>
				<if test="updateType == 'insert'">
					SET result_bank_money = result_bank_money + #{inExpMoney}
				</if>
				<if test="updateType == 'delete'">
					SET result_bank_money = (result_bank_money - #{inExpMoney})
				</if>
			</otherwise>
		</choose>		
		WHERE user_seq = #{userSeq}
		AND record_date > #{recordDate}		
		<choose>
			<when test="userBankSeq == 0">
				AND user_bank_seq IS NULL				
			</when>
			<otherwise>
	            AND user_bank_seq = #{userBankSeq}
	        </otherwise>
		</choose>
		
		
		<!-- UPDATE MONEY_RECORD
		<choose>
			<when test="bankAccount == 'readyMoney'">
				<if test="updateType == 'insert'">
					SET READY_MONEY = READY_MONEY + #{inExpMoney}
				</if>
				<if test="updateType == 'delete'">
					SET READY_MONEY = (READY_MONEY - #{inExpMoney})
				</if>
			</when>
			<when test="bankAccount != 'readyMoney'">
				<if test="updateType == 'insert'">
					SET RESULT_BANK_MONEY = RESULT_BANK_MONEY + #{inExpMoney}
				</if>
				<if test="updateType == 'delete'">
					SET RESULT_BANK_MONEY = RESULT_BANK_MONEY - #{inExpMoney}
				</if>
			</when>
		</choose>		
		WHERE USER_SEQ = #{userSeq}
		AND RECORD_DATE > #{recordDate}
		AND BANK_ACCOUNT = #{bankAccount} -->
	</update>
	
	<update id="editUpdateRecode" parameterType="Map">
		UPDATE money_record
		<set>
			<if test="recordDate != '' and recordDate != null">
				record_date = #{recordDate},
			</if>
			<if test="content != '' and content != null">
				content = #{content},		
			</if>
			<if test="purposeSeq != '' and purposeSeq != null">
				purpose_seq = #{purposeSeq},	
			</if>
			<if test="purposeDtlSeq != '' and purposeDtlSeq != null">
				pur_detail_seq = #{purposeDtlSeq}			
			</if>
		</set>
		WHERE record_seq = #{recordSeq}		
	</update>
	
	<delete id="deleteRecode" parameterType="Map">
		DELETE FROM money_record
		WHERE record_seq = #{recordSeq}	
	</delete>
	
	<insert id="insertPurpose" parameterType="java.util.List">
		 INSERT INTO purpose
		 	(user_seq, pur_order, purpose)
		 VALUES
			<foreach collection="list" item="item" separator=",">
				(#{item.userSeq}, #{item.purOrder}, #{item.purpose})
			</foreach>
	</insert>
	
	<update id="updatePurpose" parameterType="Map"> 
		UPDATE purpose SET
			pur_order = #{purOrder},
			purpose = #{purpose}
		WHERE user_seq = #{userSeq}
		AND purpose_seq = #{purposeSeq}
	</update>
	
	<delete id="deletePurpose" parameterType="java.util.List">
		DELETE FROM purpose		
		WHERE purpose_seq IN (
			<foreach collection="list" item="item" separator=",">
				#{item.purposeSeq}
			</foreach>)
	</delete>
	
	<!-- PURPOSE 삭제로 인핸 RECORD update -->
	<update id="updateRecordPurEdit" parameterType="Map">
		UPDATE money_record
		SET purpose_seq = -1
		WHERE user_seq = #{userSeq}
		AND purpose_seq = #{purposeSeq}
	</update>
	
	
	<!-- detailPurpose -->
	<insert id="insertDtlPurpose" parameterType="java.util.List">
		 INSERT INTO purpose_detail
		 	(purpose_seq, user_seq, pur_dtl_order, pur_detail)
		 VALUES
			<foreach collection="list" item="item" separator=",">
				(#{item.purposeSeq}, #{item.userSeq}, #{item.purDtlOrder}, #{item.purDetail})
			</foreach>
	</insert>
	
	<update id="updateDtlPurpose" parameterType="Map"> 
		UPDATE purpose_detail SET
			pur_dtl_order = #{purDtlOrder},
			pur_detail = #{purDetail},
			purpose_seq = #{purposeSeq}
		WHERE user_seq = #{userSeq}
		AND pur_detail_seq = #{purDetailSeq}
	</update>
	
	<delete id="deleteDtlPurpose" parameterType="java.util.List">
		DELETE FROM purpose_detail	
		WHERE pur_detail_seq IN (
			<foreach collection="list" item="item" separator=",">
				#{item.purDetailSeq}
			</foreach>)
	</delete>
	
	<!-- dtl PURPOSE 삭제로 인핸 RECORD update -->
	<update id="updateRecordDtlPurEdit" parameterType="Map">
		UPDATE money_record
		SET pur_detail_seq = -1
		WHERE user_seq = #{userSeq}
		AND pur_detail_seq = #{purDetailSeq}
	</update>
	
	
	
	<insert id="insertBank" parameterType="java.util.List">
		INSERT INTO user_bank(		
			user_seq,	
			bank_name,	
			bank_account,	
			bank_now_use_yn
		)VALUES
		<foreach collection="list" item="item" separator=",">
			(#{item.userSeq}, #{item.bankName}, #{item.bankAccount}, #{item.bankNowUseYN})
		</foreach>		
	</insert>
	
	<update id="updateBank" parameterType="Map"> 
		UPDATE user_bank SET			
			bank_name = #{bankName},
			bank_account = #{bankAccount},
			bank_now_use_yn = #{bankNowUseYN}
		WHERE user_seq = #{userSeq}
		AND user_bank_seq = #{userBankSeq}
	</update>	
	
	<update id="deleteBank" parameterType="Map">		
		UPDATE user_bank SET
			bank_now_use_yn = 'N'
		WHERE user_seq = #{userSeq}
		AND user_bank_seq = #{userBankSeq}		
	</update>
	
	
	
	
	<delete id="deleteForInitPurpose" parameterType="int">
		DELETE FROM purpose WHERE user_seq = #{userSeq}
	</delete>
	<delete id="deleteForInitUserBank" parameterType="int">
		DELETE FROM user_bank WHERE user_seq = #{userSeq}
	</delete>
	<delete id="deleteForInitRecord" parameterType="int">
		DELETE FROM money_record WHERE user_seq = #{userSeq}
	</delete>
	
	<insert id="insertBackupPurList" parameterType="PurposeBean" 
		useGeneratedKeys="true" keyProperty="purposeSeq" keyColumn="purpose_seq">
		/* insertBackupPurList */
		
		INSERT INTO purpose(			
			user_seq,
			pur_order,
			purpose
		)VALUES(
			#{userSeq},
			#{purOrder},
			#{purpose}
		)
	</insert>
	
	<!-- 미사용 -->
	<!-- <insert id="insertBackupBankList" parameterType="UserBankBean" 
		useGeneratedKeys="true" keyProperty="userBankSeq" keyColumn="user_bank_seq">
		/* insertBackupBankList */
		
		INSERT INTO user_bank(			
			user_seq,
			bank_name,
			bank_account,
			bank_now_use_yn
		)VALUES(
			#{userSeq},
			#{bankName},
			#{bankAccount},
			#{bankNowUseYN}
		)
	</insert> -->
	
									
	<!--미사용  -->
	<!-- <insert id="insertBackupRecord" parameterType="java.util.List">
		INSERT INTO money_record(				
			group_seq
			,user_seq								
			,record_date								
			,content								
			,purpose_seq								
			,user_bank_seq								
			,in_exp_money								
			,ready_money								
			,result_bank_money								
			,reg_date
		)VALUES
		<foreach collection="list" item="item" separator=",">
			(#{item.groupSeq}
			,#{item.userSeq}
			,#{item.recordDate}
			,#{item.content}
			,#{item.purposeSeq}
			
			<choose>
				<when test="item.userBankSeq == 0">
					,NULL				
				</when>
				<otherwise>
		            ,#{item.userBankSeq}
		        </otherwise>
			</choose>
			
			
			,#{item.inExpMoney}
			,#{item.readyMoney}
			,#{item.resultBankMoney}
			,#{item.regDate})	
		</foreach>		
	</insert> -->
	
</mapper>
